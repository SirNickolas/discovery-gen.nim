from   std/options import get
from   std/paths import `/`, Path
import std/sets
import std/strformat
from   std/strutils import `%`, join, replace
import std/tables
import questionable
import sourcegens/codegens
import sourcegens/emission
import sourcegens/identStyles
from   sourcegens/overridableTables import toOverridableTable
from   sourcegens/utils import dd
import ../backends
from   ../private/backends/d import Context, Settings, prepare
from   ../private/kdlDecoding import deserializeKdlDoc
from   ../rawDiscovery import DiscoveryJsonSchema

using e: var Emitter

template getKdlFieldNames(_: type Settings; field: string): seq[string] = @[
  case field
  of "pathPattern": "path"
  else: field
]

const
  camelCase = IdentStyle(wordInitial: lcUpper)
  commonTypesModule = "declarations"
  autogeneratedComment = "// Autogenerated by discovery-gen v0.x.\p"

func toComment(s: string): string =
  # TODO: Perform a smarter replacement.
  s.replace("\n", "\p///\p/// ")

proc emitDocComment(e; doc: string) =
  if doc.len != 0:
    e.emit &"/// {doc.toComment}\p"
  else:
    e.emit "///\p"

proc emitType(e; containerName: string; schema: DiscoveryJsonSchema) =
  var suffixes: seq[string]
  var schema = addr schema
  while true:
    if refName =? schema.`$ref`:
      e.emit refName
      # A simple check for self-referential types. This would handle mutual recursion incorrectly.
      if suffixes.len == 0 and refName == containerName:
        e.emit "*"
      break

    case schema.`type`:
      of "boolean":
        e.emit "bool"
        break
      of "string":
        if enumVals =? schema.`enum`:
          let members = enumVals.join(", ")
          e.emit &"// TODO: `enum {{ {members} }}`.\p"
        e.emit "string"
        break
      of "array":
        suffixes &= "[ ]"
        schema = addr schema.items.get[] # TODO: Check if it exists.
      of "object":
        without itemSchema =? schema.additionalProperties:
          e.emit "// TODO: `struct`.\pstruct"
          break
        suffixes &= "[string]"
        schema = addr itemSchema[]
      else:
        raise newException(CatchableError, "Unsupported type '" & schema.`type` & '\'')

  for i in countDown(suffixes.high, 0):
    e.emit suffixes[i]

proc emitField(e; containerName, name: string; schema: DiscoveryJsonSchema) =
  e.emitDocComment schema.description
  e.emitType containerName, schema
  e.emit &" {name.convertStyle camelCase}"
  var def = schema.default.get ""
  if def.len != 0:
    block defaultVal:
      case schema.`type`:
        of "boolean":
          if def == "false":
            break defaultVal
        of "string":
          var s = newStringOfCap def.len + 6
          s.addQuoted def
          def = s
        else:
          discard
      e.emit &" = {def}"
  e.emit ";\p"

proc emitStruct(e; schema: DiscoveryJsonSchema) =
  if schema.`type` == "object":
    e.emitDocComment schema.description
    e.emit &"struct {schema.id} {{\p"
    e.indent
    for name, field in schema.properties:
      e.emitField schema.id, name, field
    e.dedent
    e.emit "}\p"
    e.endSection

func initCommonTypesCodegen(c: Context): Codegen =
  declareCodegen('#', e):
    "autogenerated":
      e.emit autogeneratedComment

    "header":
      discard

    "module":
      e.emit &("module {c.settings.package}.{c.api.name}." & commonTypesModule & ";\p")
      e.endSection

    "imports":
      if c.needsJson:
        e.emit "import vibe.data.json: Json;\p"
      e.emit &"import {c.settings.package}.http: GoogleHttpClient;\p"
      e.endSection

    "commonParameters":
      e.emit "///\pstruct CommonParameters {\p"
      e.indent
      for fieldName, schema in c.api.parameters:
        e.emitField "", fieldName, schema
      e.dedent
      e.emit "}\p"
      e.endSection

    "googleClient":
      e.emit dd"""
      ///
      struct GoogleClient {
        GoogleHttpClient client; ///
        CommonParameters params; ///
      }
      """
      e.endSection

    "types":
      for schema in c.api.schemas.values:
        e.emitStruct schema

func initPackageCodegen(c: Context): Codegen =
  declareCodegen('#', e):
    "autogenerated":
      e.emit autogeneratedComment

    "header":
      e.emit &dd"""
      /// {c.api.title}.
      ///
      /// {c.api.description.toComment}
      ///
      """
      if link =? c.api.documentationLink:
        e.emit &dd"""
        /// {link}
        ///
        """
      # https://dlang.org/spec/ddoc.html#standard_sections
      e.emit &dd"""
      /// Version: {c.api.version}
      /// Date: {c.api.revision}
      """

    "module":
      e.emit &"module {c.settings.package}.{c.api.name};\p"
      e.endSection

func prepareFiles(c: Context): seq[(string, GenFileSpec)] =
  let root =
    (c.settings.pathPattern % c.api.name).Path /
    c.settings.package.replace('.', '/').Path /
    c.api.name.Path
  const indent = "\t" # I cannot deny tabs are more compact.
  result.add ("commonTypes", GenFileSpec(
    path: string root / Path commonTypesModule & ".d",
    indent: indent,
    codegen: c.initCommonTypesCodegen,
  ))

func initDTarget*(cfg: TargetConfig): GenFilesetSpec =
  let c = Context(api: cfg.api, settings: cfg.settings.deserializeKdlDoc(Settings, strict = false))
  {.cast(noSideEffect).}:
    c.prepare
  c.prepareFiles.toOverridableTable '#'
