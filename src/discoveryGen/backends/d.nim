from   std/math import isNaN
from   std/paths import `/`, Path
from   std/sequtils import allIt
import std/strformat
from   std/strutils import `%`, join, replace
import std/tables
import questionable
import sourcegens/codegens
import sourcegens/emission
import sourcegens/identStyles
from   sourcegens/overridableTables import toOverridableTable
from   sourcegens/utils import dd
import ../backends
import ../discovery
from   ../private/kdlDecoding import KdlDoc, deserializeKdlDoc
from   ../rawDiscovery import DiscoveryJsonSchema, DiscoveryRestDescription

type
  Settings = object
    pathPattern, package: string

  UdaName = enum
    udaBase64Encoded
    udaByName
    udaDate
    udaDateTime
    udaDuration
    udaEmbedNullable
    udaFieldMask
    udaMaximum
    udaMinimum
    udaName
    udaOptional
    udaPattern
    udaReadOnly

  StructBodyContext = object
    attrs, names: seq[string]
    forbidden: set[UdaName]

  Quoted = distinct string

using
  e: var Emitter
  api: AnalyzedApi
  c: TargetConfig
  settings: ref Settings

template getKdlFieldNames(_: type Settings; field: string): seq[string] = @[
  case field
  of "pathPattern": "path"
  else: field
]

const
  camelCase = IdentStyle(wordInitial: lcUpper)
  pascalCase = IdentStyle(initial: lcUpper, wordInitial: lcUpper)
  commonTypesModule = "declarations"
  autogeneratedComment = "// Autogenerated by discovery-gen v0.x.\p"

proc formatValue(s: var string; val: Quoted; _: string) =
  if val.string.allIt it in {' ' .. '_', 'a' .. '~'}:
    s.add '`'
    s.add val.string
    s.add '`'
  else:
    s.addQuoted val.string

func toComment(s: string): string =
  # TODO: Perform a smarter replacement.
  s.replace("\n", "\p///\p/// ")

proc emitDocComment(e; doc: string) =
  if doc.len != 0:
    e.emit &"/// {doc.toComment}\p"
  else:
    e.emit "///\p"

#[
proc emitType(e; containerName: string; schema: DiscoveryJsonSchema) =
  var suffixes: seq[string]
  var schema = addr schema
  while true:
    if refName =? schema.`$ref`:
      e.emit refName
      # A simple check for self-referential types. This would handle mutual recursion incorrectly.
      if suffixes.len == 0 and refName == containerName:
        e.emit "*"
      break

    case schema.`type`:
      of "boolean":
        e.emit "bool"
        break
      of "string":
        if schema.`enum`.len != 0:
          let members = schema.`enum`.join(", ")
          e.emit &"// TODO: `enum {{ {members} }}`.\p"
        e.emit "string"
        break
      of "array":
        suffixes &= "[ ]"
        schema = addr schema.items.unsafeGet[] # TODO: Check if it exists.
      of "object":
        without itemSchema =? schema.additionalProperties:
          e.emit "// TODO: `struct`.\pstruct"
          break
        suffixes &= "[string]"
        schema = addr itemSchema[]
      else:
        raise newException(CatchableError, "Unsupported type '" & schema.`type` & '\'')

  for i in countDown(suffixes.high, 0):
    e.emit suffixes[i]

proc emitField(e; containerName, name: string; schema: DiscoveryJsonSchema) =
  e.emitDocComment schema.description
  e.emitType containerName, schema
  e.emit &" {name.convertStyle camelCase}"
  var def = schema.default |? ""
  if def.len != 0:
    block defaultVal:
      case schema.`type`:
        of "boolean":
          if def == "false":
            break defaultVal
        of "string":
          var s = newStringOfCap def.len + 6
          s.addQuoted def
          def = s
        else:
          discard
      e.emit &" = {def}"
  e.emit ";\p"

proc emitStruct(e; schema: DiscoveryJsonSchema) =
  if schema.`type` == "object":
    e.emitDocComment schema.description
    e.emit &"struct {schema.id} {{\p"
    e.indent
    for name, field in schema.properties:
      e.emitField schema.id, name, field
    e.dedent
    e.emit "}\p"
    e.endSection
]#

func needsNullable(ty: Type): bool =
  not ty.scalar.hasDefault and ty.containers.len == 0

func formatMin(scalar: ScalarType): string =
  if scalar.kind == stkI32:
    result = $scalar.minI32
  else:
    result = $scalar.minU32
    result &= 'u'

func formatMax(scalar: ScalarType): string =
  if scalar.kind == stkI32:
    result = $scalar.maxI32
  else:
    result = $scalar.maxU32
    result &= 'u'

proc emitAltDocs(e; docs: openArray[string]) =
  if docs.len != 0:
    e.emit &"/// {docs[0].toComment}\p"
    for desc in docs.toOpenArray(1, docs.high):
      e.emit &dd"""
      /// ___
      /// {desc.toComment}
      """
  else:
    e.emit "///\p"

proc emitEnumMember(e; member: EnumMember; deprecated: bool) =
  e.emitAltDocs member.descriptions
  if deprecated:
    e.emit "deprecated "
  e.emit &"{member.name},\p" # TODO: Convert to camel case.

proc emitEnumType(e; eTy: EnumType) =
  let baseTy = if eTy.members.len <= 256: "ubyte" else: "ushort"
  e.emit &"///\penum {eTy.names[0].convertStyle pascalCase}: {baseTy} {{\p"
  e.indent
  for i, member in eTy.members:
    e.emitEnumMember member, eTy.isDeprecated i.EnumMemberId
  e.dedent
  e.emit "}\p"

func initStructBodyContext(members: openArray[StructMember]): StructBodyContext =
  result.attrs = newSeqOfCap[string] 5
  newSeq result.names, members.len
  for i, (m, _) in members:
    result.names[i] = m.name.convertStyle camelCase
    result.forbidden.incl:
      case result.names[i]
      of "base64Encoded": udaBase64Encoded
      of "byName":        udaByName
      of "date":          udaDate
      of "dateTime":      udaDateTime
      of "duration":      udaDuration
      of "embedNullable": udaEmbedNullable
      of "fieldMask":     udaFieldMask
      of "maximum":       udaMaximum
      of "minimum":       udaMinimum
      of "name":          udaName
      of "optional":      udaOptional
      of "pattern":       udaPattern
      of "readOnly":      udaReadOnly
      else: continue

iterator memberUdas(c: StructBodyContext; memberId: int; m: Member): (UdaName, string) =
  let scalar = m.ty.scalar
  if not scalar.required:
    yield if m.ty.needsNullable: (udaEmbedNullable, "embedNullable") else: (udaOptional, "optional")
  if c.names[memberId] != m.name:
    yield (udaName, &"name({Quoted m.name})")
  if scalar.readOnly:
    yield (udaReadOnly, "readOnly")
  if scalar.hasMin:
    yield (udaMinimum, &"minimum({scalar.formatMin})")
  if scalar.hasMax:
    yield (udaMaximum, &"maximum({scalar.formatMax})")
  if scalar.hasPattern:
    yield (udaPattern, &"pattern({Quoted scalar.pattern})")
  block blk:
    yield case scalar.kind:
      of stkBase64: (udaBase64Encoded, "base64Encoded")
      of stkDate: (udaDate, "date") # TODO: Use a custom type rather than a UDA.
      of stkDateTime: (udaDateTime, "dateTime") # TODO: Use a custom type rather than a UDA.
      of stkDuration: (udaDuration, "duration") # TODO: Use a custom type rather than a UDA.
      of stkFieldMask: (udaFieldMask, "fieldMask")
      of stkEnum: (udaByName, "byName")
      else: break blk

proc emitMemberUdas(e; c: var StructBodyContext; memberId: int; m: Member) =
  let scalar = m.ty.scalar
  var simpleSyntax = true
  for (uda, code) in c.memberUdas(memberId, m):
    c.attrs.add:
      if uda not_in c.forbidden:
        code
      else:
        simpleSyntax = false
        '.' & code

  if c.attrs.len != 0:
    e.emit:
      if simpleSyntax:
        var s = newStringOfCap c.attrs.len shl 4
        for a in c.attrs:
          s &= '@'
          s &= a
          s &= ' '
        s
      else:
        let s = c.attrs.join ", "
        &"@({s}) "
    c.attrs.setLen 0

proc emitMemberType(e; api; ty: Type) =
  if ty.needsNullable:
    e.emit "Nullable!"
  e.emit:
    case ty.scalar.kind
    of stkJson: "Json"
    of stkBool: "bool"
    of stkF32: "float"
    of stkF64: "double"
    of stkI32: "int"
    of stkU32: "uint"
    of stkI64: "long"
    of stkU64: "ulong"
    of stkString, stkBase64, stkDate, stkDateTime, stkDuration, stkFieldMask: "string"
    of stkEnum: api.getEnum(ty.scalar.enumId).names[0].convertStyle(pascalCase)
    of stkStruct: api.getStruct(ty.scalar.structId).names[0].convertStyle(pascalCase)
  for i in countDown(ty.containers.high, 0):
    e.emit:
      case ty.containers[i]
      of ckArray: "[ ]"
      of ckDict: "[string]"

proc emitDefaultVal(e; api; scalar: ScalarType) =
  case scalar.kind
  of stkBool:
    if scalar.defaultBool:
      e.emit " = true"
  of stkF32:
    if not scalar.defaultF32.isNaN:
      e.emit &" = {scalar.defaultF32}"
  of stkF64:
    if not scalar.defaultF64.isNaN:
      e.emit &" = {scalar.defaultF64}"
  of stkI32:
    if scalar.defaultI32 != 0:
      e.emit &" = {scalar.defaultI32}"
  of stkU32:
    if scalar.defaultU32 != 0:
      e.emit &" = {scalar.defaultU32}"
  of stkI64:
    if scalar.defaultI64 != 0:
      e.emit &" = {scalar.defaultI64}"
  of stkU64:
    if scalar.defaultU64 != 0:
      e.emit &" = {scalar.defaultU64}"
  of stkString, stkBase64, stkDate, stkDateTime, stkDuration, stkFieldMask:
    if scalar.defaultString.len != 0:
      e.emit &" = {Quoted scalar.defaultString}"
  of stkEnum:
    if scalar.defaultMember.int != 0:
      let
        eTy = api.getEnum scalar.enumId
        eName = eTy.names[0].convertStyle pascalCase
        eMemberName = eTy.getMember(scalar.defaultMember).name.convertStyle(camelCase)
      e.emit &" = {eName}.{eMemberName}"
  of stkJson, stkStruct: discard

proc emitStructBody(e; api; body: StructBody) =
  var ctx = initStructBodyContext body.members
  e.indent
  for memberId, (m, descriptions) in body.members:
    e.emitAltDocs descriptions
    e.emitMemberUdas ctx, memberId, m
    e.emitMemberType api, m.ty
    e.emit &" {ctx.names[memberId]}"
    if m.ty.scalar.hasDefault and m.ty.containers.len == 0:
      e.emitDefaultVal api, m.ty.scalar
    e.emit ";\p"

  e.dedent

func initCommonTypesCodegen(c; settings): Codegen =
  declareCodegen('#', e):
    "autogenerated":
      e.emit autogeneratedComment

    "header":
      discard

    "module":
      e.emit &("module {settings.package}.{c.rawApi.name}." & commonTypesModule & ";\p")
      e.endSection

    "publicImports":
      e.emit "public import std.typecons: Nullable, nullable; ///\p"
      e.endSection

    "imports":
      if c.api.usesJsonType:
        e.emit "import vibe.data.json: Json;\p"
      e.emit &dd"""
      import {settings.package}.attributes;
      import {settings.package}.http: GoogleHttpClient;
      """
      e.endSection

    "enums":
      for eTy in c.api.enumTypes:
        e.emitEnumType eTy
        e.endSection

    "commonParameters":
      e.emit "///\pstruct CommonParameters {\p"
      e.emitStructBody c.api, c.api.params
      e.emit "}\p"
      e.endSection

    "googleClient":
      e.emit dd"""
      ///
      struct GoogleClient {
        GoogleHttpClient client; ///
        CommonParameters params; ///
      }
      """
      e.endSection

#[
    "types":
      for schema in values c.api.schemas:
        e.emitStruct schema

func initPackageCodegen(c: Context): Codegen =
  declareCodegen('#', e):
    "autogenerated":
      e.emit autogeneratedComment

    "header":
      e.emit &dd"""
      /// {c.api.title}.
      ///
      /// {c.api.description.toComment}
      ///
      """
      if link =? c.api.documentationLink:
        e.emit &dd"""
        /// {link}
        ///
        """
      # https://dlang.org/spec/ddoc.html#standard_sections
      e.emit &dd"""
      /// Version: {c.api.version}
      /// Date: {c.api.revision}
      """

    "module":
      e.emit &"module {c.settings.package}.{c.api.name};\p"
      e.endSection
]#

func prepareFiles(c; settings): seq[(string, GenFileSpec)] =
  let root =
    (settings.pathPattern % c.rawApi.name).Path /
    settings.package.replace('.', '/').Path /
    c.rawApi.name.Path
  const indent = "\t" # I cannot deny tabs are more compact.
  result.add ("commonTypes", GenFileSpec(
    path: string root / Path commonTypesModule & ".d",
    indent: indent,
    codegen: c.initCommonTypesCodegen settings,
  ))

func deserializeSettings(doc: KdlDoc): Settings =
  doc.deserializeKdlDoc result, strict = false

func initDTarget*(c: TargetConfig; settings: sink KdlDoc): GenFilesetSpec =
  let dSettings = new Settings
  {.cast(noSideEffect).}:
    dSettings[] = settings.deserializeSettings
  c.prepareFiles(dSettings).toOverridableTable '#'
